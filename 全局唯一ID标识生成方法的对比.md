## 常用的唯一ID生成方法有：


### UUID

* 基于时间戳&时钟序列生成
* 基于随机数生成
  
### 数据库自增ID

### 雪花算法

------------------------------------------------------------------------


### 基于以上的生成唯一id的方法，分别做讲解：


#### UUID

1. 优点：
    - 无需网络，单机自行生成
    - 速度快，QPS高（支持高并发）
    - 各语言均有相应实现库供直接使用

    缺点：
    - String存储，占空间，DB查询及索引效率低
    - 无序，可读性差
    - 根据实现方式不同可能泄露信息   


2. UUID的格式
   
```java
UUID的标准形式为32位十六进制数组成的字符串，被“-”分隔开，且分隔为五个部分，如：

467e8542-2275-4163-95d6-7adc205580a9

各部分的数字个数为：8-4-4-4-12

UUID为32位的十六进制数，因此实际上是二进制的16个字节 (128-bit) ---- 1个字节＝2个16进制字符
```

3. UUID每一个版本，以及其优缺点
   
* Version1 - 基于时间的UUID：主要依赖当前的时间戳及机器mac地址，因此可以保证全球唯一性
```java
    优点：能基本保证全球唯一性
    缺点：使用了Mac地址，所以会暴露Mac地址和生成时间
```
* Version2 - 分布式安全的UUID：将版本1的时间戳前四位换为POSIX的UID或GID，很少使用
```java
    优点：能保证全球唯一性
    缺点：很少使用，常用库基本没有实现
```
* Version3 - 基于名字空间的UUID（MD5版）：基于指定的名字空间/名字生成MD5散列值得到，标准不推荐
```java
    优点：不同名字空间或名字下的UUID是唯一的；相同名字空间及名字下得到的UUID保持重复。
    缺点：MD5碰撞问题，只用于向后兼容，后续不再使用
```
* Version4 - 基于随机数的UUID：基于随机数或伪随机数生成，在分布式的情况下，最好不要用，随机的,说不准在高并发的情况就有可能重复
```java
    优点：实现简单
    缺点：重复几率可计算
```
* Version5 - 基于名字空间的UUID（SHA1版）：将版本3的散列算法改为SHA1
```java
    优点：不同名字空间或名字下的UUID是唯一的；相同名字空间及名字下得到的UUID保持重复。
    缺点：SHA1计算相对耗时
```

#### 基于以上五个版本的对比总结出：
```java
    版本1和2 适用于分布式计算环境下，需要高度唯一性且无需重复的场景
    版本3和5 适用于一定范围内唯一且需要，或可能会重复生成UUID的环境下
    版本4 适用于对唯一性要求不太严格且追求简单的场景
```

***

#### 数据库自增ID


1. 优点：
   - 天然有序

   缺点：
   - 并发性不好
   - 数据库写压力大
   - 数据库故障后不可使用
   - 存在数量泄露风险

2. 针对以上的缺点给予以下两种方案：
* 1. 数据库水平拆分，设置不同的初始值和相同的步长。如图：
![数据库水平拆分](/images/数据库水平拆分.png)

如图所示，可保证每台数据库生成的ID是不冲突的，但这种固定步长的方式也会带来扩容的问题，很容易想到当扩容时会出现无ID初始值可分的窘境，解决方案有：
   * 根据扩容考虑决定步长
   * 增加其他位标记区分扩容
  
这其实都是在需求与方案间的权衡，根据需求来选择最适合的方式

* 2. 批量生成一批ID
  
如果要使用单台机器做ID生成，避免固定步长带来的扩容问题，可以每次批量生成一批ID给不同的机器去慢慢消费，这样数据库的压力也会减小到N分之一，且故障后可坚持一段时间。如图：
![批量生成一批ID](/images/批量生成一批ID.png)

***

#### 雪花算法

定义一个64bit的数，对指定机器 & 同一时刻 & 某一并发序列，是唯一的，其极限QPS约为400w/s。其格式为：
![雪花算法图示1](/images/雪花算法图示1.png)
![雪花算法图示2](/images/雪花算法图示2.png)


```java
将64 bit分为了四部分。其中时间戳有时间上限（69年）。机器id只有10位，能记录1024台机器，常用前几位表示数据中心id，后几位表示数据中心内的机器id。序列号用来对同一个毫秒之内的操作产生不同的ID，最多4095个。

这种结构是雪花算法提出者Twitter的分法，但实际上这种算法使用可以很灵活，根据自身业务的并发情况、机器分布、使用年限等，可以自由地重新决定各部分的位数，从而增加或减少某部分的量级。比如百度的UidGenerator、美团的Leaf等，都是基于雪花算法做一些适合自身业务的变化。
```

* 由于雪花算法是强依赖于时间的，在分布式环境下，如果发生时钟回拨，很可能会引起id冲突的问题。解决方案有：

    - 将ID生成交给少量服务器，并关闭时钟同步。
    - 直接报错，交给上层业务处理。
    - 如果回拨时间较短，在耗时要求内，比如5ms，那么等待回拨时长后再进行生成。
    - 如果回拨时间很长，那么无法等待，可以匀出少量位（1~2位）作为回拨位，一旦时钟回拨，将回拨位加1，可得到不一样的ID，2位回拨位允许标记三次时钟回拨，基本够使用。如果超出了，可以再选择抛出异常。


***

### 各种方案都有其优缺点，技术的使用没有绝对的好坏之分，主要在于是否适合使用场景：

* 要求生成全局唯一且不会重复ID，不关心顺序 —— 使用基于时间的UUID（如游戏聊天室中不同用户的身份ID）
* 要求生成唯一ID，具有名称不可变性，可重复生成 —— 使用基于名称哈希的UUID（如基于不可变信息生成的用户ID，若不小心删除，仍可根据信息重新生成同一ID）
* 要求生成有序且自然增长的ID —— 使用数据库自增ID（如各业务操作流水ID，高并发下可参考优化方案）
* 要求生成数值型无序定长ID —— 使用雪花算法（如对存储空间、查询效率、传输数据量等有较高要求的场景）
  
  
### 唯一ID特性，各方案的对比如下：
![唯一ID特性对比图](/images/唯一ID特性对比图.png)